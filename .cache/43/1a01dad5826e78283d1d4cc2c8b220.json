{"id":"yunshi/index.html","dependencies":[{"name":"/Users/mac/Desktop/workspace/learning/canvas/.postcssrc","includedInParent":true,"mtime":1560132466632},{"name":"_css_loader","parent":"/Users/mac/Desktop/workspace/learning/canvas/src/yunshi/index.html","resolved":"/Users/mac/Desktop/workspace/learning/canvas/node_modules/_parcel-bundler@1.12.3@parcel-bundler/src/builtins/css-loader.js"},{"name":"/Users/mac/Desktop/workspace/learning/canvas/.babelrc","includedInParent":true,"mtime":1560132449326},{"name":"/Users/mac/Desktop/workspace/learning/canvas/package.json","includedInParent":true,"mtime":1560133689733},{"name":"/Users/mac/Desktop/workspace/learning/canvas/.browserslistrc","includedInParent":true,"mtime":1560132463869}],"generated":{"html":"<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>黑色星空，陨石坠落canvas特效 — HelloWeb前端网</title>\r\n<style>body {\r\n\tbackground: #000;\r\n}</style>\r\n</head>\r\n<body>\r\n<div id=\"helloweb\"><canvas></canvas></div>\r\n\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js\"></script> \r\n<script>function getMat(color) {\n  // our material is a phong material, with no shininess (highlight) and a black specular\n  return new THREE.MeshStandardMaterial({\n    color: color,\n    roughness: .9,\n    transparent: true,\n    opacity: 0,\n    emissive: 0x270000,\n    shading: THREE.FlatShading\n  });\n}\n\nvar Colors = {\n  red: 0xf85051,\n  orange: 0xea8962,\n  yellow: 0xdacf75,\n  beige: 0xccc58f,\n  grey: 0xbab7a1,\n  blue: 0x4379a8,\n  ocean: 0x4993a8,\n  green: 0x24a99b\n};\nvar colorsLength = Object.keys(Colors).length;\n\nfunction randomRange(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction getRandomColor() {\n  var colIndx = Math.floor(Math.random() * colorsLength);\n  var colorStr = Object.keys(Colors)[colIndx];\n  return Colors[colorStr];\n}\n\nfunction shiftPosition(pos, radius) {\n  if (Math.abs(pos) < radius) {\n    if (pos >= 0) {\n      return pos + radius;\n    } else {\n      return pos - radius;\n    }\n  } else {\n    return pos;\n  }\n} // Default parameters\n\n\nvar parameters = {\n  minRadius: 30,\n  maxRadius: 50,\n  minSpeed: .015,\n  maxSpeed: .025,\n  particles: 500,\n  minSize: .1,\n  maxSize: 2\n}; // For a THREEJS project we need at least\n// a scene\n// a renderer\n// a camera\n// a light (1 or many)\n// a mesh (an object to display)\n\nvar scene, renderer, camera, light;\nvar stars = [];\nvar nbPlanetsMax = 4;\nvar planets = [];\nvar WIDTH = window.innerWidth,\n    HEIGHT = window.innerHeight; // initialise the world\n\nfunction initWorld() {\n  scene = new THREE.Scene();\n  camera = new THREE.PerspectiveCamera(75, WIDTH / HEIGHT, .1, 2000);\n  camera.position.z = 100; //\n  // THE RENDERER\n  //\n\n  renderer = new THREE.WebGLRenderer({\n    alpha: true,\n    antialias: true\n  });\n  renderer.setSize(WIDTH, HEIGHT);\n  renderer.shadowMap.enabled = true;\n  container = document.getElementById('helloweb');\n  container.appendChild(renderer.domElement); // Lights\n\n  ambientLight = new THREE.AmbientLight(0x663344, 2);\n  scene.add(ambientLight);\n  light = new THREE.DirectionalLight(0xffffff, 1.5);\n  light.position.set(200, 100, 200);\n  light.castShadow = true;\n  light.shadow.camera.left = -400;\n  light.shadow.camera.right = 400;\n  light.shadow.camera.top = 400;\n  light.shadow.camera.bottom = -400;\n  light.shadow.camera.near = 1;\n  light.shadow.camera.far = 1000;\n  light.shadow.mapSize.width = 2048;\n  light.shadow.mapSize.height = 2048;\n  scene.add(light); //\n  // HANDLE SCREEN RESIZE\n  //\n\n  window.addEventListener('resize', handleWindowResize, false); // Creating firts planets\n\n  for (var i = 0; i < nbPlanetsMax; i++) {\n    planets.push(new Planet(-2000 / nbPlanetsMax * i - 500));\n  }\n\n  addStarts();\n  loop();\n}\n\nfunction animateStars(z) {\n  // loop through each star\n  for (var i = 0; i < stars.length; i++) {\n    star = stars[i]; // if the particle is too close move it to the back\n\n    if (star.position.z > z) star.position.z -= 2000;\n  }\n}\n\nfunction addStarts() {\n  for (var z = -2000; z < 0; z += 20) {\n    var geometry = new THREE.SphereGeometry(0.5, 32, 32);\n    var material = new THREE.MeshBasicMaterial({\n      color: 0xffffff\n    });\n    var sphere = new THREE.Mesh(geometry, material);\n    sphere.position.x = randomRange(-1 * Math.floor(WIDTH / 2), Math.floor(WIDTH / 2));\n    sphere.position.y = randomRange(-1 * Math.floor(HEIGHT / 2), Math.floor(HEIGHT / 2)); // Then set the z position to where it is in the loop (distance of camera)\n\n    sphere.position.z = z; // scale it up a bit\n\n    sphere.scale.x = sphere.scale.y = 2; //add the sphere to the scene\n\n    scene.add(sphere); //finally push it to the stars array\n\n    stars.push(sphere);\n  }\n}\n\nvar Planet = function Planet(z) {\n  // the geometry of the planet is a tetrahedron\n  this.planetRadius = randomRange(12, 30);\n  var planetDetail = randomRange(2, 3);\n  var geomPlanet = new THREE.TetrahedronGeometry(this.planetRadius, planetDetail);\n  var noise = randomRange(1, 5);\n\n  for (var i = 0; i < geomPlanet.vertices.length; i++) {\n    var v = geomPlanet.vertices[i];\n    v.x += -noise / 2 + Math.random() * noise;\n    v.y += -noise / 2 + Math.random() * noise;\n    v.z += -noise / 2 + Math.random() * noise;\n  } // create a new material for the planet\n\n\n  var color = getRandomColor();\n  var matPlanet = getMat(color); // create the mesh of the planet\n\n  this.planet = new THREE.Mesh(geomPlanet, matPlanet);\n  this.ring = new THREE.Mesh();\n  this.nParticles = 0; // create the particles to populate the ring\n\n  this.updateParticlesCount(); // Create a global mesh to hold the planet and the ring\n\n  this.mesh = new THREE.Object3D();\n  this.mesh.add(this.planet);\n  this.mesh.add(this.ring);\n  this.planet.castShadow = true;\n  this.planet.receiveShadow = true; // update the position of the particles => must be moved to the loop\n\n  this.mesh.rotation.x = (Math.random() * 2 - 1) * 2 * Math.PI;\n  this.mesh.rotation.z = (Math.random() * 2 - 1) * 2 * Math.PI;\n  var posX = randomRange(-1 * Math.floor(WIDTH / 4), Math.floor(WIDTH / 4));\n  var posY = randomRange(-1 * Math.floor(HEIGHT / 4), Math.floor(HEIGHT / 4));\n  posX = shiftPosition(posX, this.planetRadius);\n  posY = shiftPosition(posY, this.planetRadius);\n  this.mesh.position.set(posX, posY, z);\n  scene.add(this.mesh);\n};\n\nPlanet.prototype.destroy = function () {\n  scene.remove(this.mesh);\n};\n\nPlanet.prototype.updateParticlesCount = function () {\n  var parameters = {\n    minRadius: randomRange(this.planetRadius + 10, 60),\n    maxRadius: randomRange(40, 70),\n    minSpeed: randomRange(0, 5) * 0.1 + randomRange(0, 9) * 0.01,\n    maxSpeed: randomRange(0, 5) * 0.1 + randomRange(0, 9) * 0.01,\n    particles: randomRange(0, 1) * randomRange(20, 30),\n    minSize: randomRange(1, 3) + randomRange(0, 9) * 0.1,\n    maxSize: randomRange(1, 3) + randomRange(0, 9) * 0.1\n  };\n\n  if (this.nParticles < parameters.particles) {\n    // Remove particles\n    for (var i = this.nParticles; i < parameters.particles; i++) {\n      var p = new Particle();\n      p.mesh.rotation.x = Math.random() * Math.PI;\n      p.mesh.rotation.y = Math.random() * Math.PI;\n      p.mesh.position.y = -2 + Math.random() * 4;\n      this.ring.add(p.mesh);\n    }\n  } else {\n    // add particles\n    while (this.nParticles > parameters.particles) {\n      var m = this.ring.children[this.nParticles - 1];\n      this.ring.remove(m);\n      m.userData.po = null;\n      this.nParticles--;\n    }\n  }\n\n  this.nParticles = parameters.particles; // We will give a specific angle to each particle\n  // to cover the whole ring we need to\n  // dispatch them regularly\n\n  this.angleStep = Math.PI * 2 / this.nParticles;\n  this.updateParticlesDefiniton();\n}; // Update particles definition\n\n\nPlanet.prototype.updateParticlesDefiniton = function () {\n  for (var i = 0; i < this.nParticles; i++) {\n    var m = this.ring.children[i];\n    var s = parameters.minSize + Math.random() * (parameters.maxSize - parameters.minSize);\n    m.scale.set(s, s, s); // set a random distance\n\n    m.userData.distance = parameters.minRadius + Math.random() * (parameters.maxRadius - parameters.minRadius); // give a unique angle to each particle\n\n    m.userData.angle = this.angleStep * i; // set a speed proportionally to the distance\n\n    m.userData.angularSpeed = rule3(m.userData.distance, parameters.minRadius, parameters.maxRadius, parameters.minSpeed, parameters.maxSpeed);\n  }\n};\n\nvar Particle = function Particle() {\n  // Size of the particle, make it random\n  var s = 1; // geometry of the particle, choose between different shapes\n\n  var geom,\n      random = Math.random();\n\n  if (random < .25) {\n    // Cube\n    geom = new THREE.BoxGeometry(s, s, s);\n  } else if (random < .5) {\n    // Pyramid\n    geom = new THREE.CylinderGeometry(0, s, s * 2, 4, 1);\n  } else if (random < .75) {\n    // potato shape\n    geom = new THREE.TetrahedronGeometry(s, 2);\n  } else {\n    // thick plane\n    geom = new THREE.BoxGeometry(s / 6, s, s); // thick plane\n  } // color of the particle, make it random and get a material\n\n\n  var color = getRandomColor();\n  var mat = getMat(color); // create the mesh of the particle\n\n  this.mesh = new THREE.Mesh(geom, mat);\n  this.mesh.receiveShadow = true;\n  this.mesh.castShadow = true;\n  this.mesh.userData.po = this;\n}; // Update particles position\n\n\nPlanet.prototype.updateParticlesRotation = function () {\n  // increase the rotation of each particle\n  // and update its position\n  for (var i = 0; i < this.nParticles; i++) {\n    var m = this.ring.children[i]; // increase the rotation angle around the planet\n\n    m.userData.angle += m.userData.angularSpeed; // calculate the new position\n\n    var posX = Math.cos(m.userData.angle) * m.userData.distance;\n    var posZ = Math.sin(m.userData.angle) * m.userData.distance;\n    m.position.x = posX;\n    m.position.z = posZ; //*\n    // add a local rotation to the particle\n\n    m.rotation.x += Math.random() * .05;\n    m.rotation.y += Math.random() * .05;\n    m.rotation.z += Math.random() * .05; //*/\n  }\n};\n\nfunction addPlanet(z) {\n  planets.push(new Planet(z));\n}\n\nfunction loop() {\n  var horizon = -2000 + camera.position.z;\n\n  for (var i = 0; i < planets.length; i++) {\n    if (planets[i].mesh.position.z > camera.position.z) {\n      planets[i].destroy();\n      planets.splice(i, 1);\n    } // If the planet is arriving\n\n\n    if (planets[i].mesh.position.z > horizon && planets[i].planet.material.opacity < 1) {\n      planets[i].planet.material.opacity += 0.005;\n\n      for (var j = 0; j < planets[i].mesh.children[1].children.length; j++) {\n        planets[i].mesh.children[1].children[j].material.opacity += 0.005;\n      }\n    }\n  } // Adding stars\n\n\n  animateStars(camera.position.z);\n\n  if (planets.length < nbPlanetsMax) {\n    addPlanet(camera.position.z - 2000);\n  }\n\n  for (var i = 0; i < planets.length; i++) {\n    planets[i].planet.rotation.y -= 0.01;\n    planets[i].updateParticlesRotation();\n  }\n\n  camera.position.z -= 3; //\n  // RENDER !\n  //\n\n  renderer.render(scene, camera); //\n  // REQUEST A NEW FRAME\n  //\n\n  requestAnimationFrame(loop);\n}\n\nfunction handleWindowResize() {\n  // Recalculate Width and Height as they had changed\n  HEIGHT = window.innerHeight;\n  WIDTH = window.innerWidth; // Update the renderer and the camera\n\n  renderer.setSize(WIDTH, HEIGHT);\n  camera.aspect = WIDTH / HEIGHT;\n  camera.updateProjectionMatrix();\n}\n\ninitWorld();\n\nfunction rule3(v, vmin, vmax, tmin, tmax) {\n  var nv = Math.max(Math.min(v, vmax), vmin);\n  var dv = vmax - vmin;\n  var pc = (nv - vmin) / dv;\n  var dt = tmax - tmin;\n  var tv = tmin + pc * dt;\n  return tv;\n}</script>\r\n</body>\r\n</html>"},"sourceMaps":null,"error":null,"hash":"78d1f44710d79cffa96ad281c1f9e5b6","cacheData":{"env":{}}}